// NoirWire SDK - Main entry point

import axios, { AxiosInstance } from "axios";
import { Connection, PublicKey } from "@solana/web3.js";
import * as bip39 from "bip39";
import nacl from "tweetnacl";
import type { NoirWireWalletConfig, Balance, ZkProof, ApiResponse } from "@noirwire/types";
import { generateSalt, bytesToHex } from "@noirwire/utils";

// Re-export crypto and proof modules
export * from "./crypto";
export * from "./proof";

// Re-export PER and config modules
export * from "./per";
export * from "./config";

// ============================================
// NoirWire Wallet
// ============================================

export class NoirWireWallet {
  private secretKey: Uint8Array;
  private publicKey: Uint8Array;
  private connection: Connection;

  private constructor(secretKey: Uint8Array, config: NoirWireWalletConfig) {
    this.secretKey = secretKey;
    const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);
    this.publicKey = keyPair.publicKey;

    const rpcUrl = config.rpcUrl || this.getDefaultRpcUrl(config.network);
    this.connection = new Connection(rpcUrl, "confirmed");
  }

  private getDefaultRpcUrl(network: NoirWireWalletConfig["network"]): string {
    switch (network) {
      case "mainnet":
        return "https://api.mainnet-beta.solana.com";
      case "devnet":
        return "https://api.devnet.solana.com";
      case "localnet":
        return "http://localhost:8899";
    }
  }

  /**
   * Generate a new wallet with random keys
   */
  static generate(config: NoirWireWalletConfig = { network: "devnet" }): NoirWireWallet {
    const keyPair = nacl.sign.keyPair();
    return new NoirWireWallet(keyPair.secretKey, config);
  }

  /**
   * Restore wallet from mnemonic phrase
   */
  static fromMnemonic(
    mnemonic: string,
    config: NoirWireWalletConfig = { network: "devnet" },
  ): NoirWireWallet {
    if (!bip39.validateMnemonic(mnemonic)) {
      throw new Error("Invalid mnemonic phrase");
    }
    const seed = bip39.mnemonicToSeedSync(mnemonic).slice(0, 32);
    const keyPair = nacl.sign.keyPair.fromSeed(seed);
    return new NoirWireWallet(keyPair.secretKey, config);
  }

  /**
   * Restore wallet from secret key
   */
  static fromSecretKey(
    secretKey: Uint8Array,
    config: NoirWireWalletConfig = { network: "devnet" },
  ): NoirWireWallet {
    return new NoirWireWallet(secretKey, config);
  }

  /**
   * Generate a new mnemonic phrase
   */
  static generateMnemonic(): string {
    return bip39.generateMnemonic(256); // 24 words
  }

  /**
   * Get the public key as hex string
   */
  getPublicKeyHex(): string {
    return bytesToHex(this.publicKey);
  }

  /**
   * Get the Solana public key
   */
  getSolanaPublicKey(): PublicKey {
    return new PublicKey(this.publicKey);
  }

  /**
   * Export the secret key (use with caution!)
   */
  exportSecretKey(): Uint8Array {
    return this.secretKey.slice();
  }
}

// ============================================
// NoirWire Client
// ============================================

export interface NoirWireClientConfig {
  apiUrl: string;
  network: NoirWireWalletConfig["network"];
  rpcUrl?: string;
}

export class NoirWireClient {
  private config: NoirWireClientConfig;
  private wallet: NoirWireWallet | null = null;
  private api: AxiosInstance;

  constructor(config: NoirWireClientConfig) {
    this.config = config;
    this.api = axios.create({
      baseURL: config.apiUrl,
      timeout: 30000,
      headers: {
        "Content-Type": "application/json",
      },
    });
  }

  /**
   * Connect a wallet to the client
   */
  connect(wallet: NoirWireWallet): void {
    this.wallet = wallet;
  }

  /**
   * Disconnect the wallet
   */
  disconnect(): void {
    this.wallet = null;
  }

  /**
   * Check if a wallet is connected
   */
  isConnected(): boolean {
    return this.wallet !== null;
  }

  /**
   * Get the connected wallet
   */
  getWallet(): NoirWireWallet {
    if (!this.wallet) {
      throw new Error("No wallet connected");
    }
    return this.wallet;
  }

  // ============================================
  // Deposit Operations
  // ============================================

  /**
   * Deposit SOL into the shielded pool
   */
  async deposit(amount: bigint): Promise<string> {
    const wallet = this.getWallet();

    // Generate commitment
    const salt = generateSalt();
    // Balance will be used for commitment calculation
    const _balance: Balance = {
      owner: wallet.getPublicKeyHex(),
      amount,
      salt,
    };

    // TODO: Generate ZK proof locally
    const proof: ZkProof = {
      proof: "", // Placeholder - will be generated by Noir circuit
      publicInputs: [],
    };

    // Send deposit request to API
    const response = await this.api.post<ApiResponse<{ signature: string }>>("/deposits", {
      commitment: bytesToHex(new Uint8Array(32)), // TODO: Calculate real commitment
      amount: amount.toString(),
      proof: proof.proof,
      publicInputs: proof.publicInputs,
    });

    if (!response.data.success) {
      throw new Error(response.data.error || "Deposit failed");
    }

    return response.data.data!.signature;
  }

  // ============================================
  // Transfer Operations
  // ============================================

  /**
   * Transfer SOL privately to another user
   */
  async transfer(recipientPubkey: string, amount: bigint): Promise<string> {
    // Wallet will be used for proof generation
    const _wallet = this.getWallet();

    // TODO: Generate ZK proof locally
    const proof: ZkProof = {
      proof: "", // Placeholder - will be generated by Noir circuit
      publicInputs: [],
    };

    // Send transfer request to API
    const response = await this.api.post<ApiResponse<{ signature: string }>>("/transfers", {
      nullifier: bytesToHex(new Uint8Array(32)), // TODO: Calculate real nullifier
      newCommitment: bytesToHex(new Uint8Array(32)), // TODO: Calculate real commitment
      recipient: recipientPubkey,
      amount: amount.toString(),
      proof: proof.proof,
      publicInputs: proof.publicInputs,
    });

    if (!response.data.success) {
      throw new Error(response.data.error || "Transfer failed");
    }

    return response.data.data!.signature;
  }

  // ============================================
  // Withdraw Operations
  // ============================================

  /**
   * Withdraw SOL from the shielded pool
   */
  async withdraw(amount: bigint, recipientAddress: string): Promise<string> {
    // Wallet will be used for proof generation
    const _wallet = this.getWallet();

    // TODO: Generate ZK proof locally
    const proof: ZkProof = {
      proof: "", // Placeholder - will be generated by Noir circuit
      publicInputs: [],
    };

    // Send withdraw request to API
    const response = await this.api.post<ApiResponse<{ signature: string }>>("/withdrawals", {
      nullifier: bytesToHex(new Uint8Array(32)), // TODO: Calculate real nullifier
      recipient: recipientAddress,
      amount: amount.toString(),
      proof: proof.proof,
      publicInputs: proof.publicInputs,
    });

    if (!response.data.success) {
      throw new Error(response.data.error || "Withdrawal failed");
    }

    return response.data.data!.signature;
  }

  // ============================================
  // Query Operations
  // ============================================

  /**
   * Get pool status and statistics
   */
  async getPoolStatus(): Promise<{
    totalDeposits: string;
    merkleRoot: string;
  }> {
    const response =
      await this.api.get<ApiResponse<{ totalDeposits: string; merkleRoot: string }>>(
        "/health/pool",
      );

    if (!response.data.success) {
      throw new Error(response.data.error || "Failed to get pool status");
    }

    return response.data.data!;
  }

  /**
   * Get Merkle proof for a commitment
   */
  async getMerkleProof(commitment: string): Promise<{ siblings: string[]; pathIndices: number[] }> {
    const response = await this.api.get<ApiResponse<{ siblings: string[]; pathIndices: number[] }>>(
      `/merkle/proof/${commitment}`,
    );

    if (!response.data.success) {
      throw new Error(response.data.error || "Failed to get Merkle proof");
    }

    return response.data.data!;
  }
}

// ============================================
// Exports
// ============================================

// Re-export types, excluding names that conflict with crypto module
export type {
  ApiResponse,
  Commitment,
  Nullifier,
  NoirWireWalletConfig,
  EncryptedNote,
  Vault,
  VaultMember,
  ZkProof,
  TransferProofInputs,
  DepositProofInputs,
  WithdrawProofInputs,
  TransactionType,
  TransactionStatus,
  Transaction,
} from "@noirwire/types";

// Re-export utils - Balance is defined in crypto module
export * from "@noirwire/utils";
