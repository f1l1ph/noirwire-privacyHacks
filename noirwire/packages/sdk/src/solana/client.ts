/**
 * NoirWire SDK - Solana Program Client
 * Direct integration with shielded-pool program via Anchor
 */

import { AnchorProvider, Program, BN } from "@coral-xyz/anchor";
import {
  Connection,
  PublicKey,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  Transaction,
  TransactionInstruction,
  Keypair,
  ComputeBudgetProgram,
} from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
} from "@solana/spl-token";

// Import IDL type (will be auto-generated by Anchor)
import type { ShieldedPool } from "./types/shielded_pool";
import shieldedPoolIdl from "../../../solana-programs/target/idl/shielded_pool.json";

/**
 * Program IDs for NoirWire programs
 */
export const PROGRAM_IDS = {
  SHIELDED_POOL: new PublicKey("NWRZDZJMfUAd3iVvdMhpsKht5bgHZGPzynHhQ2JssQ2"),
  ZK_VERIFIER: new PublicKey("NWRNe5ezj9SxCXVqrXbycbpT8drAvuaBknX3ChgGbnx"),
};

/**
 * Proof data structure matching Solana program
 */
export interface Groth16ProofData {
  a: Uint8Array; // 64 bytes - G1 point
  b: Uint8Array; // 128 bytes - G2 point
  c: Uint8Array; // 64 bytes - G1 point
}

/**
 * Deposit proof data for Solana instruction
 */
export interface DepositProofData {
  proof: Groth16ProofData;
  depositAmount: Uint8Array; // 32 bytes - Field element
  newCommitment: Uint8Array; // 32 bytes
  leafIndex: Uint8Array; // 32 bytes
  oldRoot: Uint8Array; // 32 bytes
  newRoot: Uint8Array; // 32 bytes
}

/**
 * Withdraw proof data for Solana instruction
 */
export interface WithdrawProofData {
  proof: Groth16ProofData;
  amount: Uint8Array; // 32 bytes
  recipient: Uint8Array; // 32 bytes (recipient pubkey as field element)
  nullifier: Uint8Array; // 32 bytes
  oldRoot: Uint8Array; // 32 bytes
  newRoot: Uint8Array; // 32 bytes
}

/**
 * Pool configuration
 */
export interface PoolConfig {
  tokenMint: PublicKey;
  authority: PublicKey;
  perAuthority?: PublicKey; // Optional PER TEE authority
}

/**
 * Transaction result
 */
export interface TransactionResult {
  signature: string;
  slot: number;
}

/**
 * Solana program client for shielded pool operations
 */
export class SolanaClient {
  private program: Program<ShieldedPool>;
  private connection: Connection;
  private tokenMint: PublicKey;

  constructor(connection: Connection, tokenMint: PublicKey, provider?: AnchorProvider) {
    this.connection = connection;
    this.tokenMint = tokenMint;

    // Create provider if not provided
    if (!provider) {
      // Use a dummy wallet for read-only operations
      const dummyWallet = {
        publicKey: SystemProgram.programId,
        signTransaction: async (tx: Transaction) => tx,
        signAllTransactions: async (txs: Transaction[]) => txs,
      };
      provider = new AnchorProvider(connection, dummyWallet as any, {
        commitment: "confirmed",
      });
    }

    // Initialize Anchor program
    // @ts-ignore - IDL type compatibility
    this.program = new Program(shieldedPoolIdl as any, provider);
  }

  /**
   * Get pool PDA address
   */
  getPoolAddress(): PublicKey {
    const [poolPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("pool"), this.tokenMint.toBuffer()],
      PROGRAM_IDS.SHIELDED_POOL,
    );
    return poolPda;
  }

  /**
   * Get pool vault PDA address
   */
  getPoolVaultAddress(): PublicKey {
    const poolAddress = this.getPoolAddress();
    const [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), poolAddress.toBuffer()],
      PROGRAM_IDS.SHIELDED_POOL,
    );
    return vaultPda;
  }

  /**
   * Get pool authority PDA address
   */
  getPoolAuthorityAddress(): PublicKey {
    const poolAddress = this.getPoolAddress();
    const [authorityPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("authority"), poolAddress.toBuffer()],
      PROGRAM_IDS.SHIELDED_POOL,
    );
    return authorityPda;
  }

  /**
   * Get nullifier PDA address
   */
  getNullifierAddress(nullifier: Uint8Array): PublicKey {
    const poolAddress = this.getPoolAddress();
    const [nullifierPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("nullifier"), poolAddress.toBuffer(), nullifier],
      PROGRAM_IDS.SHIELDED_POOL,
    );
    return nullifierPda;
  }

  /**
   * Get historical roots PDA address
   */
  getHistoricalRootsAddress(): PublicKey {
    const poolAddress = this.getPoolAddress();
    const [historicalRootsPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("historical_roots"), poolAddress.toBuffer()],
      PROGRAM_IDS.SHIELDED_POOL,
    );
    return historicalRootsPda;
  }

  /**
   * Fetch pool state
   */
  async getPoolState(): Promise<any> {
    const poolAddress = this.getPoolAddress();
    // @ts-ignore - Account namespace is dynamic
    return await this.program.account.poolState.fetch(poolAddress);
  }

  /**
   * Create deposit instruction
   */
  async createDepositInstruction(
    depositor: PublicKey,
    amount: BN,
    proofData: DepositProofData,
    verificationKey: PublicKey,
  ): Promise<TransactionInstruction> {
    const poolAddress = this.getPoolAddress();
    const poolVault = this.getPoolVaultAddress();

    // Get user's token account
    const userTokenAccount = await getAssociatedTokenAddress(this.tokenMint, depositor);

    // Get historical roots PDA (optional, but recommended for production)
    const historicalRoots = this.getHistoricalRootsAddress();

    // Build deposit instruction
    // @ts-ignore - Methods are dynamic based on IDL
    return await this.program.methods
      .deposit(amount, {
        proof: proofData.proof,
        depositAmount: Array.from(proofData.depositAmount),
        newCommitment: Array.from(proofData.newCommitment),
        leafIndex: Array.from(proofData.leafIndex),
        oldRoot: Array.from(proofData.oldRoot),
        newRoot: Array.from(proofData.newRoot),
      })
      .accounts({
        pool: poolAddress,
        userTokenAccount,
        poolVault,
        verificationKey,
        verifierProgram: PROGRAM_IDS.ZK_VERIFIER,
        depositor,
        historicalRoots, // Optional but recommended
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .instruction();
  }

  /**
   * Create withdraw instruction
   */
  async createWithdrawInstruction(
    payer: PublicKey,
    recipient: PublicKey,
    proofData: WithdrawProofData,
    verificationKey: PublicKey,
  ): Promise<TransactionInstruction> {
    const poolAddress = this.getPoolAddress();
    const poolVault = this.getPoolVaultAddress();
    const poolAuthority = this.getPoolAuthorityAddress();
    const nullifierEntry = this.getNullifierAddress(proofData.nullifier);

    // Get recipient's token account
    const recipientTokenAccount = await getAssociatedTokenAddress(this.tokenMint, recipient);

    // Get historical roots PDA (optional, but recommended for production)
    const historicalRoots = this.getHistoricalRootsAddress();

    // Build withdraw instruction
    // @ts-ignore - Methods are dynamic based on IDL
    return await this.program.methods
      .withdraw(
        {
          proof: proofData.proof,
          amount: Array.from(proofData.amount),
          recipient: Array.from(proofData.recipient),
          nullifier: Array.from(proofData.nullifier),
          oldRoot: Array.from(proofData.oldRoot),
          newRoot: Array.from(proofData.newRoot),
        },
        recipient,
      )
      .accounts({
        pool: poolAddress,
        poolVault,
        recipientTokenAccount,
        nullifierEntry,
        verificationKey,
        verifierProgram: PROGRAM_IDS.ZK_VERIFIER,
        payer,
        poolAuthority,
        historicalRoots, // Optional but recommended
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .instruction();
  }

  /**
   * Execute deposit transaction
   */
  async deposit(
    depositor: Keypair,
    amount: BN,
    proofData: DepositProofData,
    verificationKey: PublicKey,
  ): Promise<TransactionResult> {
    // Create compute budget instruction (ZK verification is compute-intensive)
    const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({
      units: 400_000, // Deposit verification needs ~300k-400k CU
    });

    // Create deposit instruction
    const depositIx = await this.createDepositInstruction(
      depositor.publicKey,
      amount,
      proofData,
      verificationKey,
    );

    // Build and send transaction
    const tx = new Transaction().add(computeBudgetIx, depositIx);

    const signature = await this.connection.sendTransaction(tx, [depositor], {
      skipPreflight: false,
      preflightCommitment: "confirmed",
    });

    // Wait for confirmation
    const { context } = await this.connection.confirmTransaction(signature, "confirmed");

    return {
      signature,
      slot: context.slot,
    };
  }

  /**
   * Execute withdraw transaction
   */
  async withdraw(
    payer: Keypair,
    recipient: PublicKey,
    proofData: WithdrawProofData,
    verificationKey: PublicKey,
  ): Promise<TransactionResult> {
    // Create compute budget instruction (ZK verification is compute-intensive)
    const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({
      units: 500_000, // Withdraw verification needs ~400k-500k CU
    });

    // Check if recipient token account exists, create if not
    const recipientTokenAccount = await getAssociatedTokenAddress(this.tokenMint, recipient);

    const accountInfo = await this.connection.getAccountInfo(recipientTokenAccount);
    const instructions: TransactionInstruction[] = [computeBudgetIx];

    if (!accountInfo) {
      // Create associated token account
      const createAtaIx = createAssociatedTokenAccountInstruction(
        payer.publicKey,
        recipientTokenAccount,
        recipient,
        this.tokenMint,
      );
      instructions.push(createAtaIx);
    }

    // Create withdraw instruction
    const withdrawIx = await this.createWithdrawInstruction(
      payer.publicKey,
      recipient,
      proofData,
      verificationKey,
    );

    instructions.push(withdrawIx);

    // Build and send transaction
    const tx = new Transaction().add(...instructions);

    const signature = await this.connection.sendTransaction(tx, [payer], {
      skipPreflight: false,
      preflightCommitment: "confirmed",
    });

    // Wait for confirmation
    const { context } = await this.connection.confirmTransaction(signature, "confirmed");

    return {
      signature,
      slot: context.slot,
    };
  }

  /**
   * Get current merkle root from pool state
   */
  async getCurrentRoot(): Promise<Uint8Array> {
    const poolState = await this.getPoolState();
    return new Uint8Array(poolState.merkleRoot);
  }

  /**
   * Get pool statistics
   */
  async getPoolStatistics(): Promise<{
    totalDeposits: BN;
    merkleRoot: Uint8Array;
    leafCount: number;
  }> {
    const poolState = await this.getPoolState();
    return {
      totalDeposits: poolState.totalDeposits,
      merkleRoot: new Uint8Array(poolState.merkleRoot),
      leafCount: poolState.leafCount,
    };
  }
}

/**
 * Create a Solana client instance
 */
export function createSolanaClient(
  connection: Connection,
  tokenMint: PublicKey,
  provider?: AnchorProvider,
): SolanaClient {
  return new SolanaClient(connection, tokenMint, provider);
}
